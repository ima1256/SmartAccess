// // SmartAccess.Domain/Entities/User.cs
// public class User
// {
//     public Guid Id { get; set; }
//     public string Username { get; set; }
//     public string RFIDCard { get; set; }
//     public bool IsActive { get; set; }
// }


// public interface IUserRepository
// {
//     Task<User?> GetByIdAsync(Guid id);
//     Task AddAsync(User user);
// }



// public class RegisterUserUseCase
// {
//     private readonly IUserRepository _repo;
//     public RegisterUserUseCase(IUserRepository repo) => _repo = repo;

//     public async Task Execute(UserDto dto)
//     {
//         var user = new User { Id = Guid.NewGuid(), Username = dto.Username, RFIDCard = dto.RFIDCard };
//         await _repo.AddAsync(user);
//     }
// }

// //sqlcmd -S ima1256server.database.windows.net -d AccessControlDB -U CloudSA1868eb93 -P rh*617/latH

// dotnet add SmartAccess.Infrastructure package Microsoft.EntityFrameworkCore.SqlServer
// dotnet add SmartAccess.Infrastructure package Microsoft.EntityFrameworkCore.Tools

// using SmartAccess.Domain.Entities;

// namespace SmartAccess.Domain.Repositories
// {
//     public interface IUserRepository
//     {
//         Task<User?> GetByIdAsync(Guid id);
//         Task AddAsync(User user);
//     }
// }

// namespace SmartAccess.Application.DTOs
// {
//     public class UserDto
//     {
//         public string Username { get; set; } = string.Empty;
//         public string RFIDCard { get; set; } = string.Empty;
//     }
// }


// using Microsoft.EntityFrameworkCore;
// using SmartAccess.Domain.Entities;
// using SmartAccess.Domain.Repositories;
// using SmartAccess.Infrastructure.Persistence;

// namespace SmartAccess.Infrastructure.Repositories
// {
//     public class UserRepository : IUserRepository
//     {
//         private readonly SmartAccessDbContext _context;

//         public UserRepository(SmartAccessDbContext context)
//         {
//             _context = context;
//         }

//         public async Task<User?> GetByIdAsync(Guid id)
//         {
//             return await _context.Users.FindAsync(id);
//         }

//         public async Task AddAsync(User user)
//         {
//             _context.Users.Add(user);
//             await _context.SaveChangesAsync();
//         }
//     }
// }

// // using Microsoft.EntityFrameworkCore;
// // using SmartAccess.Application.UseCases;
// // using SmartAccess.Domain.Repositories;
// // using SmartAccess.Infrastructure.Persistence;
// // using SmartAccess.Infrastructure.Repositories;

// // var builder = WebApplication.CreateBuilder(args);

// // // Database
// // builder.Services.AddDbContext<SmartAccessDbContext>(options =>
// //     options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// // // DI
// // builder.Services.AddScoped<IUserRepository, UserRepository>();
// // builder.Services.AddScoped<RegisterUserUseCase>();

// // // Controller & swagger
// // builder.Services.AddControllers();
// // builder.Services.AddEndpointsApiExplorer();
// // builder.Services.AddSwaggerGen();

// // var app = builder.Build();
// // app.UseSwagger();
// // app.UseSwaggerUI();
// // app.MapControllers();
// // app.Run();




// dotnet add reference ../SmartAccess.Infrastructure/SmartAccess.Infrastructure.csproj








// using Microsoft.EntityFrameworkCore;
// using SmartAccess.Domain.Entities;

// namespace SmartAccess.Infrastructure.Persistence
// {
//     public class SmartAccessDbContext : DbContext
//     {
//         public SmartAccessDbContext(DbContextOptions<SmartAccessDbContext> options)
//             : base(options)
//         {
//         }

//         public DbSet<User> Users => Set<User>();
//     }
// }


// using Microsoft.AspNetCore.Mvc;
// using SmartAccess.Application.DTOs;
// using SmartAccess.Application.UseCases;

// namespace SmartAccess.API.Controllers
// {
//     [ApiController]
//     [Route("api/[controller]")]
//     public class UsersController : ControllerBase
//     {
//         private readonly RegisterUserUseCase _registerUser;

//         public UsersController(RegisterUserUseCase registerUser)
//         {
//             _registerUser = registerUser;
//         }

//         [HttpPost("register")]
//         public async Task<IActionResult> Register(UserDto dto)
//         {
//             await _registerUser.Execute(dto);
//             return Ok("User registered successfully.");
//         }
//     }
// }


// dotnet ef migrations add InitialCreate --project SmartAccess.Infrastructure --startup-project SmartAccess.API

// dotnet tool install --global dotnet-ef

// dotnet ef migrations add InitialCreate --project SmartAccess.Infrastructure --startup-project SmartAccess.API

// dotnet ef database update --project SmartAccess.Infrastructure --startup-project SmartAccess.API


// public interface IUserRepository
// {
//     Task<User?> GetByIdAsync(Guid id);
//     Task AddAsync(User user);
//     Task UpdateAsync(User user);
//     Task DeleteAsync(Guid id);
//     Task<IEnumerable<User>> GetAllAsync();
// }


// public class GetUserByIdUseCase
// {
//     private readonly IUserRepository _repo;

//     public GetUserByIdUseCase(IUserRepository repo) => _repo = repo;

//     public async Task<User?> Execute(Guid id) => await _repo.GetByIdAsync(id);
// }

// // SmartAccess.Domain/Entities/Door.cs
// public class Door
// {
//     public Guid Id { get; set; }
//     public string Name { get; set; } = string.Empty;
//     public bool IsLocked { get; set; } = true;
// }

// public class AccessLog
// {
//     public Guid Id { get; set; }
//     public Guid UserId { get; set; }
//     public Guid DoorId { get; set; }
//     public DateTime Timestamp { get; set; }
//     public bool AccessGranted { get; set; }
// }

// [HttpGet]
// public async Task<IActionResult> GetAll()
// {
//     var users = await _getAllUsers.Execute();
//     return Ok(users);
// }

// public async Task<IEnumerable<User>> Search(string text)
// {
//     return await _context.Users
//         .Where(u => u.Username.Contains(text))
//         .ToListAsync();
// }


// public class SearchUsersUseCase
// {
//     private readonly IUserRepository _repo;

//     public SearchUsersUseCase(IUserRepository repo)
//     {
//         _repo = repo;
//     }

//     public async Task<IEnumerable<UserDto>> Execute(string? username = null, bool? isEnabled = null)
//     {
//         var users = await _repo.SearchAsync(username, isEnabled);

//         return users.Select(u => new UserDto
//         {
//             Id = u.Id,
//             Username = u.Username,
//             RFIDCard = u.RFIDCard,
//             IsEnabled = u.IsEnabled
//         });
//     }
// }


// var query = _context.Users.AsQueryable();

// if (!string.IsNullOrWhiteSpace(username))
//     query = query.Where(u => u.Username.Contains(username));

// if (isEnabled.HasValue)
//     query = query.Where(u => u.IsEnabled == isEnabled.Value);

// return await query.ToListAsync();

public class UsersControllerTests
{
    private readonly UsersController _controller;
    private readonly Mock<RegisterUserUseCase> _registerUser = new();
    private readonly Mock<GetUserByIdUseCase> _getUserById = new();
    private readonly Mock<GetAllUsersUseCase> _getAllUsers = new();
    private readonly Mock<UpdateUserUseCase> _updateUser = new();
    private readonly Mock<DeleteUserUseCase> _deleteUser = new();
    private readonly Mock<SearchUsersUseCase> _searchUsers = new();
    private readonly Mock<SetUserStatusUseCase> _setUserStatus = new();

    public UsersControllerTests()
    {
        _controller = new UsersController(
            _setUserStatus.Object,
            _searchUsers.Object,
            _deleteUser.Object,
            _updateUser.Object,
            _registerUser.Object,
            _getUserById.Object,
            _getAllUsers.Object
        );
    }

    [Fact]
    public async Task Register_ReturnsOkResult()
    {
        // Arrange
        var dto = new UserDto { FirstName = "Juan", LastName = "Pérez", Email = "juan@test.com" };

        // Act
        var result = await _controller.Register(dto);

        // Assert
        result.Should().BeOfType<OkObjectResult>();
        _registerUser.Verify(u => u.Execute(dto), Times.Once);
    }

    [Fact]
    public async Task Register_NullDto_ReturnsBadRequest()
    {
        // Act
        var result = await _controller.Register(null);

        // Assert
        result.Should().BeOfType<BadRequestResult>();
        _registerUser.Verify(u => u.Execute(It.IsAny<UserDto>()), Times.Never);
    }

    [Fact]
    public async Task Register_EmptyUsername_ReturnsBadRequest()
    {
        // Arrange
        var dto = new UserDto { Username = "", RFIDCard = "RFID123", IsActive = true };

        // Act
        var result = await _controller.Register(dto);

        // Assert
        result.Should().BeOfType<BadRequestObjectResult>();
    }

    [Fact]
    public async Task Register_ThrowsException_Returns500()
    {
        // Arrange
        var dto = new UserDto { Username = "ErrorUser", RFIDCard = "XXXX", IsActive = false };
        _registerUser.Setup(u => u.Execute(dto)).ThrowsAsync(new Exception("Database error"));

        // Act
        var result = await _controller.Register(dto);

        // Assert
        result.Should().BeOfType<ObjectResult>()
            .Which.StatusCode.Should().Be(500);
    }

    //dotnet add package FluentValidation.AspNetCore

    //     using FluentValidation;
    // using SmartAccess.Application.DTOs;

    // public class UserDtoValidator : AbstractValidator<UserDto>
    // {
    //     public UserDtoValidator()
    //     {
    //         RuleFor(x => x.Username).NotEmpty().WithMessage("Username is required");
    //         RuleFor(x => x.RFIDCard).NotEmpty().WithMessage("RFID Card is required");
    //         // Puedes agregar más reglas aquí
    //     }
    // }

    //dotnet publish -c Release -r linux-x64 --self-contained true -p:PublishSingleFile=true -p:PublishTrimmed=true


    // docker build -t smartaccess-api .
    // docker run -d -p 5000:80 smartaccess-api

    //docker run -d -p 5000:80 smartaccess-api




}


// [HttpGet("{id}")]
// public async Task<IActionResult> Get(Guid id)
// {
//     try
//     {
//         var user = await _getUserById.Execute(id);

//         if (user == null)
//         {
//             _logger.LogWarning("User not found. ID: {UserId}", id);
//             return NotFound($"User with ID {id} was not found.");
//         }

// if (id == Guid.Empty)
// {
//     return BadRequest("The provided user ID is invalid.");
// }

//         return Ok(user);
//     }
//     catch (Exception ex)
//     {
//         _logger.LogError(ex, "Error retrieving user with ID: {UserId}", id);
//         return StatusCode(500, "An internal server error occurred.");
//     }
// }


// [Fact]
// public async Task Get_UserExists_ReturnsOk()
// { ... }

// [Fact]
// public async Task Get_UserDoesNotExist_ReturnsNotFound()
// { ... }

// [Fact]
// public async Task Get_UserExists_ReturnsOk()
// {
//     // Arrange
//     var userId = Guid.NewGuid();
//     var expectedUser = new UserDto
//     {
//         Username = "testuser",
//         RFIDCard = "RFID123",
//         IsActive = true
//     };

//     _getUserById
//         .Setup(s => s.Execute(userId))
//         .ReturnsAsync(expectedUser);

//     // Act
//     var result = await _controller.Get(userId);

//     // Assert
//     result.Should().BeOfType<OkObjectResult>();

//     var okResult = result as OkObjectResult;
//     okResult!.Value.Should().BeEquivalentTo(expectedUser);

//     _getUserById.Verify(s => s.Execute(userId), Times.Once);
// }

//dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection

// User -> UserDto
// CreateMap<User, UserDto>()
//     .ForMember(dest => dest.Id, opt => opt.MapFrom(src => src.Id.ToString()));

// // UserDto -> User
// CreateMap<UserDto, User>()
//     .ForMember(dest => dest.Id, opt => opt.MapFrom(src => Guid.Parse(src.Id)))
//     .ForMember(dest => dest.Role, opt => opt.Ignore()); // si no viene del DTO




// ✅ 4.Usa AutoMapper en tu controlador/servicio
// Inyecta IMapper:

// csharp
// Copiar
// Editar
// private readonly IMapper _mapper;

// public UserController(IMapper mapper /* otros deps */)
// {
//     _mapper = mapper;
// }
// Y úsalo así:

// csharp
// Copiar
// Editar
// var user = await _repo.GetByIdAsync(id);

// // Entity -> DTO
// var dto = _mapper.Map<UserDto>(user);

// // DTO -> Entity
// var entity = _mapper.Map<User>(dto);
// ✅ 5.BONUS: Métodos ToDto() y ToEntity() usando extensión(opcional)
// Si prefieres una API fluida y más legible, puedes agregar extensiones por encima de AutoMapper:

// csharp
// Copiar
// Editar
// public static class UserMappingExtensions
// {
//     public static UserDto ToDto(this User user, IMapper mapper)
//         => mapper.Map<UserDto>(user);

//     public static User ToEntity(this UserDto dto, IMapper mapper)
//         => mapper.Map<User>(dto);
// }
// Uso:

// csharp
// Copiar
// Editar
// var dto = user.ToDto(_mapper);
// var entity = dto.ToEntity(_mapper);
// ✅ ¿Y los tests?
// Puedes probar el perfil así:

// csharp
// Copiar
// Editar
// [Fact]
// public void UserProfile_Configuration_IsValid()
// {
//     var config = new MapperConfiguration(cfg => cfg.AddProfile<UserProfile>());
//     config.AssertConfigurationIsValid(); // lanza excepción si hay errores
// }

// [Fact]
// public async Task Get_EmptyGuid_ReturnsBadRequest()
// {
//     // Arrange
//     var invalidId = Guid.Empty;

//     // Act
//     var result = await _controller.Get(invalidId);

//     // Assert
//     result.Should().BeOfType<BadRequestObjectResult>();

//     var badRequest = result as BadRequestObjectResult;
//     badRequest!.Value.Should().Be("The provided user ID is invalid.");

//     _getUserById.Verify(s => s.Execute(It.IsAny<Guid>()), Times.Never);
// }


// [Fact]
// public async Task Get_ExceptionThrown_ReturnsInternalServerError()
// {
//     // Arrange
//     var userId = Guid.NewGuid();
//     _getUserById.Setup(s => s.Execute(userId)).ThrowsAsync(new Exception("Something went wrong"));

//     // Act
//     var result = await _controller.Get(userId);

//     // Assert
//     result.Should().BeOfType<ObjectResult>();

//     var objectResult = result as ObjectResult;
//     objectResult!.StatusCode.Should().Be(500);
//     objectResult.Value.Should().Be("An internal server error ocurred.");

//     _getUserById.Verify(s => s.Execute(userId), Times.Once);
// }
